<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sudoku Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .glow {
      box-shadow: 0 0 10px rgba(168, 85, 247, 0.5); /* Tailwind purple-500 */
    }
    .cell {
      transition: all 0.2s ease-in-out;
    }
    .cell:focus {
      outline: none;
      box-shadow: 0 0 15px rgba(168, 85, 247, 0.7);
    }
    .error {
      background-color: rgba(168, 85, 247, 0.2);
    }
    .grid-container {
      display: grid;
      grid-template-columns: repeat(9, minmax(0, 1fr));
      gap: 1px;
      background-color: #1f2937; /* Tailwind gray-800 */
      position: relative;
    }
    .cell-container {
      position: relative;
    }
    /* Vertical 3x3 subgrid borders */
    .cell-container:nth-child(3n):not(:nth-child(9n))::after {
      content: '';
      position: absolute;
      right: -2px;
      top: 0;
      height: 100%;
      width: 3px;
      background-color: #a855f7; /* Tailwind purple-500 */
    }
    /* Horizontal 3x3 subgrid borders */
    .cell-container:nth-child(n+19):nth-child(-n+27)::before,
    .cell-container:nth-child(n+46):nth-child(-n+54)::before {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      width: 100%;
      height: 3px;
      background-color: #a855f7;
    }
    /* Outer border for the entire grid */
    .grid-container::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      border: 3px solid #a855f7;
      border-radius: 8px;
      pointer-events: none;
    }
  </style>
</head>
<body class="bg-gray-900 flex flex-col items-center justify-center min-h-screen p-4">
  <div class="bg-black rounded-2xl p-6 glow max-w-md w-full">
    <h1 class="text-3xl font-bold text-purple-500 text-center mb-4">Sudoku</h1>
    <div class="mb-4 flex justify-between items-center">
      <select id="difficulty" class="bg-gray-800 text-purple-500 rounded-lg p-2 glow">
        <option value="easy">Easy</option>
        <option value="medium">Medium</option>
        <option value="hard">Hard</option>
      </select>
      <div id="timer" class="text-purple-500 font-semibold">00:00</div>
    </div>
    <div id="grid" class="grid-container p-2 rounded-lg">
      <!-- Grid cells will be generated by JavaScript -->
    </div>
    <div class="mt-4 flex justify-between">
      <button id="newGame" class="bg-purple-500 text-white px-4 py-2 rounded-lg glow hover:bg-purple-600">New Game</button>
      <button id="check" class="bg-purple-500 text-white px-4 py-2 rounded-lg glow hover:bg-purple-600">Check Solution</button>
    </div>
    <p id="message" class="mt-4 text-center text-purple-500"></p>
  </div>

  <script>
    const gridElement = document.getElementById('grid');
    const difficultySelect = document.getElementById('difficulty');
    const newGameButton = document.getElementById('newGame');
    const checkButton = document.getElementById('check');
    const timerElement = document.getElementById('timer');
    const messageElement = document.getElementById('message');
    let grid = [];
    let solution = [];
    let timerInterval;
    let startTime;

    // Generate a 9x9 grid with input cells
    function createGrid() {
      gridElement.innerHTML = '';
      grid = Array(9).fill().map(() => Array(9).fill(0));
      for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
          const div = document.createElement('div');
          div.className = 'cell-container';
          const input = document.createElement('input');
          input.type = 'text';
          input.maxLength = 1;
          input.className = 'cell w-10 h-10 text-center text-purple-500 bg-black rounded-md border border-gray-700 focus:border-purple-500';
          input.addEventListener('input', (e) => {
            const value = e.target.value;
            if (value && !/^[1-9]$/.test(value)) {
              e.target.value = '';
            } else {
              grid[i][j] = value ? parseInt(value) : 0;
            }
          });
          div.appendChild(input);
          gridElement.appendChild(div);
        }
      }
    }

    // Generate a Sudoku puzzle based on difficulty
    function generatePuzzle(difficulty) {
      solution = [
        [5,3,4,6,7,8,9,1,2],
        [6,7,2,1,9,5,3,4,8],
        [1,9,8,3,4,2,5,6,7],
        [8,5,9,7,6,1,4,2,3],
        [4,2,6,8,5,3,7,9,1],
        [7,1,3,9,2,4,8,5,6],
        [9,6,1,5,3,7,2,8,4],
        [2,8,7,4,1,9,6,3,5],
        [3,4,5,2,8,6,1,7,9]
      ];
      grid = solution.map(row => row.slice());
      const removeCount = { easy: 40, medium: 50, hard: 60 }[difficulty];
      for (let i = 0; i < removeCount; i++) {
        const row = Math.floor(Math.random() * 9);
        const col = Math.floor(Math.random() * 9);
        grid[row][col] = 0;
      }
      renderGrid();
    }

    // Render the grid to the UI
    function renderGrid() {
      const inputs = gridElement.querySelectorAll('input');
      inputs.forEach((input, index) => {
        const row = Math.floor(index / 9);
        const col = index % 9;
        input.value = grid[row][col] || '';
        input.disabled = grid[row][col] !== 0;
        input.classList.remove('error');
      });
      resetTimer();
    }

    // Start or reset the timer
    function resetTimer() {
      clearInterval(timerInterval);
      startTime = Date.now();
      timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
        const seconds = String(elapsed % 60).padStart(2, '0');
        timerElement.textContent = `${minutes}:${seconds}`;
      }, 1000);
    }

    // Check if the grid is fully filled
    function isGridFilled() {
      return grid.every(row => row.every(cell => cell !== 0));
    }

    // Check the solution
    function checkSolution() {
      if (!isGridFilled()) {
        messageElement.textContent = 'Please fill all cells before checking.';
        return;
      }
      let correct = true;
      const inputs = gridElement.querySelectorAll('input');
      for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
          const index = i * 9 + j;
          if (grid[i][j] !== solution[i][j]) {
            inputs[index].classList.add('error');
            correct = false;
          } else {
            inputs[index].classList.remove('error');
          }
        }
      }
      messageElement.textContent = correct ? 'Congratulations! You solved it!' : 'There are errors in your solution.';
    }

    // Start a new game
    function startNewGame() {
      const difficulty = difficultySelect.value;
      createGrid();
      generatePuzzle(difficulty);
      messageElement.textContent = '';
    }

    // Event listeners
    newGameButton.addEventListener('click', startNewGame);
    checkButton.addEventListener('click', checkSolution);
    difficultySelect.addEventListener('change', startNewGame);

    // Initialize the game
    startNewGame();

    // Handle pinch-to-zoom
    document.addEventListener('gesturestart', (e) => e.preventDefault());
    document.addEventListener('touchmove', (e) => {
      if (e.scale !== 1) {
        e.preventDefault();
      }
    }, { passive: false });
  </script>
</body>
</html>